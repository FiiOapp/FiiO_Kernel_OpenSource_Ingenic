#include <linux/i2c.h>
#include <media/jz_cim.h>
#include <asm/jzsoc.h>

#define CIM_SENSOR_NAME "gc2035"
static struct resolution_info gc2035_resolution_table[] = {
	{1600, 1200, 16},
	{1280, 960, 16},
	{800, 600, 16},
};

typedef struct {
	unsigned char reg;
	unsigned char val;
} SENSOR_REG_T;

static unsigned debug = 0;	//normal debug (0: disable)
static unsigned level = 1;
#define gc2035_printk(level, fmt, arg...)         \
	printk(level fmt, ## arg)

#define gc2035_dbg(level, debug, fmt, arg...)			\
	do { 							\
		if (debug >= (level))				\
			gc2035_printk(KERN_INFO, fmt, ## arg); 	\
	} while (0)

#define dprintk(fmt, arg...)                   	  \
	gc2035_dbg(level, debug, fmt, ## arg)

//输出 YUV422 -- YUYV
static unsigned int preshutter = 0;
static void gc2035_reset(int rst);
SENSOR_REG_T sensor_init_data[]=
{
	{0xfe , 0x80},
	{0xfe , 0x80},
	{0xfe , 0x80},
	{0xfc , 0x06},
	{0xf2 , 0x00},
	{0xf3 , 0x00},
	{0xf4 , 0x00},
	{0xf5 , 0x00},
	{0xf9 , 0xfe}, //[0] pll enable
	{0xfa , 0x00},
	//{0xfa , 0x22},
	{0xf6 , 0x00},
	{0xf7 , 0x15}, //pll enable
	//{0xf7 , 0x19}, //pll enable
	{0xf8 , 0x87},//0x84
	{0xfe , 0x00},
	{0x82 , 0x00},
	{0xb3 , 0x60},
	{0xb4 , 0x40},
	{0xb5 , 0x60},

	{0x03 , 0x02},
	{0x04 , 0xdc},

	////measure window  ///
	{0xfe , 0x00},
	{0xec , 0x06},//04 2012.10.26
	{0xed , 0x06},//04 2012.10.26
	{0xee , 0x62},//60 2012.10.26
	{0xef , 0x92},//90 2012.10.26

	////analog///
	{0x0a , 0x00}, //row start
	{0x0c , 0x00}, //col start
	{0x0d , 0x04},
	{0x0e , 0xc0},
	{0x0f , 0x06}, //Window setting
	{0x10 , 0x58},
	//	{0x17 , 0x14}, //[0]mirror [1]flip
	{0x17 , 0x17}, //[0]mirror [1]flip
	{0x18 , 0x0e}, //
	{0x19 , 0x0c}, //
	{0x1a , 0x01}, //
	{0x1b , 0x8b},
	{0x1c , 0x05},// add by lanking 20130403
	{0x1e , 0x88}, //
	{0x1f , 0x08}, //[3] tx-low en//
	{0x20 , 0x05}, //
	{0x21 , 0x0f}, //
	{0x22 , 0xd0}, // f0 20130403
	{0x23 , 0xc3}, //
	{0x24 , 0x17}, //  16

	//AEC
	{0xfe , 0x01},
	{0x11 , 0x20},//
	{0x1f , 0xc0},//max_post_gain
	{0x20 , 0x60},//max_pre_gain
	{0x47 , 0x30},//AEC_outdoor_th
	{0x0b , 0x10},//
	{0x13 , 0x65},//y_target
	{0xfe , 0x00},

	{0x05 , 0x01},//hb
	{0x06 , 0x0d},
	{0x07 , 0x00},//vb
	{0x08 , 0x40},

	{0xfe , 0x01},
	{0x27 , 0x00},//step
	{0x28 , 0xa0},

	{0x29 , 0x05},//level1
	{0x2a , 0x00},

	{0x2b , 0x05},//level2
	{0x2c , 0x00},

	{0x2d , 0x05},//level3
	{0x2e , 0x00},

	{0x2f , 0x05},//level4
	{0x30 , 0x00},

	{0xfe , 0x00},
	{0xfe , 0x00},  //0x , 0x , 0x , 0x , 0x
	{0xb6 , 0x03}, //AEC enable
	{0xfe , 0x00},

	/////BLK//////
	{0x3f , 0x00}, //prc close
	{0x40 , 0x77},//
	{0x42 , 0x7f},
	{0x43 , 0x30},
	{0x5c , 0x08},
	{0x5e , 0x20},
	{0x5f , 0x20},
	{0x60 , 0x20},
	{0x61 , 0x20},
	{0x62 , 0x20},
	{0x63 , 0x20},
	{0x64 , 0x20},
	{0x65 , 0x20},

	///block////
	{0x80 , 0xff},
	{0x81 , 0x26},//
	{0x87 , 0x90}, //
	{0x84 , 0x02}, //output put foramat
	{0x86 , 0x02}, ////sync plority  02 86
	//{0x86 , 0x06}, ////sync plority  02 86
	{0x8b , 0xbc},
	{0xb0 , 0x80}, //globle gain
	{0xc0 , 0x40},//Yuv bypass

	////lsc///

	{0xfe , 0x01},
	{0xc2 , 0x19},
	{0xc3 , 0x11},
	{0xc4 , 0x0d},
	//	{0xc8 , 0x1f},
	{0xc8 , 0x21},
	{0xc9 , 0x14},
	//	{0xca , 0x10},
	{0xca , 0x13},
	{0xbc , 0x2d},
	{0xbd , 0x25},
	{0xbe , 0x12},
	{0xb6 , 0x35},
	{0xb7 , 0x1d},
	{0xb8 , 0x1d},
	{0xc5 , 0x00},
	{0xc6 , 0x00},
	{0xc7 , 0x00},
	{0xcb , 0x00},
	{0xcc , 0x00},
	{0xcd , 0x00},
	{0xbf , 0x00},
	{0xc0 , 0x00},
	{0xc1 , 0x0c},
	{0xb9 , 0x00},
	{0xba , 0x00},
	{0xbb , 0x00},
	{0xaa , 0x00},
	{0xab , 0x00},
	{0xac , 0x00},
	{0xad , 0x05},
	{0xae , 0x05},
	{0xaf , 0x08},
	//	{0xb0 , 0x0a},
	{0xb0 , 0x16},
	{0xb1 , 0x05},
	//	{0xb2 , 0x0a},
	{0xb2 , 0x18},
	{0xb3 , 0x06},
	{0xb4 , 0x06},
	{0xb5 , 0x0b},
	{0xd0 , 0x00},
	{0xd2 , 0x03},
	{0xd3 , 0x14},
	{0xd8 , 0x00},
	{0xda , 0x00},
	{0xdb , 0x09},
	{0xdc , 0x00},
	{0xde , 0x00},
	{0xdf , 0x08},
	{0xd4 , 0x0e},
	{0xd6 , 0x0c},
	{0xd7 , 0x18},
	{0xa4 , 0x00},
	{0xa5 , 0x00},
	{0xa6 , 0x00},
	{0xa7 , 0x00},
	{0xa8 , 0x02},
	{0xa9 , 0x00},
	{0xa1 , 0x80},
	{0xa2 , 0x80},
	///cc////
	{0xfe , 0x02},
	{0xc0 , 0x01},
	{0xc1 , 0x40}, //
	{0xc2 , 0xfc},
	{0xc3 , 0x05},
	{0xc4 , 0xec},
	{0xc5 , 0x42},
	{0xc6 , 0xf8},
	{0xc7 , 0x40},//for cwf
	{0xc8 , 0xf8},
	{0xc9 , 0x06},
	{0xca , 0xfd},
	{0xcb , 0x3e},
	{0xcc , 0xf3},
	{0xcd , 0x36},//for A
	{0xce , 0xf6},
	{0xcf , 0x04},
	{0xe3 , 0x0c},
	{0xe4 , 0x44},
	{0xe5 , 0xe5},
	{0xfe , 0x00},

	///awb start ///
	//AWB clear
	{0xfe , 0x01},
	{0x4f , 0x00},
	{0x4d , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x10}, // 10
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x20}, // 20
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x30},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00}, // 30
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x40}, // 40
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x50}, // 50
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x60}, // 60
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x70}, // 70
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x80}, // 80
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x90}, // 90
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0xa0}, // a0
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0xb0}, // b0
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0xc0}, // c0
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0xd0}, // d0
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4f , 0x01},
	// awb value//
	{0xfe , 0x01},
	{0x4f , 0x00},
	{0x4d , 0x30},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x02},//7000k
	{0x4e , 0x02},//SPL D65
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x40},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x08},//SPL cwf
	{0x4e , 0x04},//5000K
	{0x4e , 0x02},//d65
	{0x4e , 0x02},//SPL D65
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x50},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x10},//10//SPL TL84&skin
	{0x4e , 0x04},//5000K&skin  outdoor cloudy
	{0x4e , 0x04},//outdoor cloudy
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x60},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x10},//10//SPL TL84&skin
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4d , 0x70},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x20},//SPL a
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4e , 0x00},
	{0x4f , 0x01},


	/////awb////
	{0xfe , 0x01},
	{0x50 , 0x88},//
	{0x52 , 0x40},
	{0x54 , 0x60},
	{0x56 , 0x06},
	{0x57 , 0x20}, //pre adjust
	{0x58 , 0x01},
	{0x5b , 0x02}, //AWB_gain_delta
	{0x61 , 0xaa},//R/G stand
	{0x62 , 0xaa},//R/G stand
	{0x71 , 0x00},
	{0x74 , 0x10},  //
	{0x77 , 0x08}, //
	{0x78 , 0xfd}, //AWB_p2_y
	{0x86 , 0x30},
	{0x87 , 0x00},
	{0x88 , 0x04},//06 , 0x//[1]dark mode
	{0x8a , 0xc0},//
	{0x89 , 0x75},
	{0x84 , 0x08},  //
	{0x8b , 0x00}, //
	{0x8d , 0x70}, //awb gain limit R
	{0x8e , 0x70},//G
	{0x8f , 0xf4},//B
	{0xfe , 0x00},
	{0x82 , 0x02},//awb_en
	/////awb end ////

	///asde
	{0xfe , 0x01},
	{0x21 , 0xbf},
	{0xfe , 0x02},
	{0xa4 , 0x00},//
	{0xa5 , 0x40}, //lsc_th
	{0xa2 , 0xa0}, //lsc_dec_slope
	{0xa6 , 0x80}, //dd_th
	{0xa7 , 0x80}, //ot_th
	{0xab , 0x31}, //
	{0xa9 , 0x6f}, //
	{0xb0 , 0x99}, //
	{0xb1 , 0x34},//
	{0xb3 , 0x80}, //
	{0xde , 0xb6},  //
	{0x38 , 0x0f}, //
	{0x39 , 0x60}, //
	{0xfe , 0x00},
	{0x81 , 0x26},
	{0xfe , 0x02},
	{0x83 , 0x00},//
	{0x84 , 0x45},//
	////YCP///
	{0xd1 , 0x2e},//saturation_cb
	{0xd2 , 0x2e},//saturation_Cr
	{0xd3 , 0x42},//
	{0xd4 , 0x80},//
	{0xd5 , 0x00},//
	{0xdc , 0x30},
	{0xdd , 0xb8},//edge_sa_g,b
	{0xfe , 0x00},
	///////dndd////
	{0xfe , 0x02},
	{0x88 , 0x1f},//dn_b_base
	{0x8c , 0xf6}, //[2]b_in_dark_inc
	{0x89 , 0x01}, //dn_c_weight
	////////EE //
	{0xfe , 0x02},
	{0x90 , 0x6c},//
	{0x97 , 0x45},// edge effect
	////RGB Gamma
	{0xfe , 0x02},
	{0x15 , 0x0a},
	{0x16 , 0x12},
	{0x17 , 0x19},
	{0x18 , 0x1f},
	{0x19 , 0x2c},
	{0x1a , 0x38},
	{0x1b , 0x42},
	{0x1c , 0x4e},
	{0x1d , 0x63},
	{0x1e , 0x76},
	{0x1f , 0x87},
	{0x20 , 0x96},
	{0x21 , 0xa2},
	{0x22 , 0xb8},
	{0x23 , 0xca},
	{0x24 , 0xd8},
	{0x25 , 0xe3},
	{0x26 , 0xf0},
	{0x27 , 0xf8},
	{0x28 , 0xfd},
	{0x29 , 0xff},

	////Small Gamma
	/*
	   {0xfe , 0x02},
	   {0x15 , 0x0b},
	   {0x16 , 0x0e},
	   {0x17 , 0x10},
	   {0x18 , 0x12},
	   {0x19 , 0x19},
	   {0x1a , 0x21},
	   {0x1b , 0x29},
	   {0x1c , 0x31},
	   {0x1d , 0x41},
	   {0x1e , 0x50},
	   {0x1f , 0x5f},
	   {0x20 , 0x6d},
	   {0x21 , 0x79},
	   {0x22 , 0x91},
	   {0x23 , 0xa5},
	   {0x24 , 0xb9},
	   {0x25 , 0xc9},
	   {0x26 , 0xe1},
	   {0x27 , 0xee},
	   {0x28 , 0xf7},
	   {0x29 , 0xff},
	 */

	{0xfe , 0x02},
	{0x2b , 0x00},
	{0x2c , 0x04},
	{0x2d , 0x09},
	{0x2e , 0x18},
	{0x2f , 0x27},
	{0x30 , 0x37},
	{0x31 , 0x49},
	{0x32 , 0x5c},
	{0x33 , 0x7e},
	{0x34 , 0xa0},
	{0x35 , 0xc0},
	{0x36 , 0xe0},
	{0x37 , 0xff},


	/*  /////re zao ///
	    {0xfe,0x00},
	    {0x22,0xd0},
	    {0xfe,0x01},
	    {0x21,0xff},
	    {0xfe,0x02},
	    {0x8a,0x33},
	    {0x8c,0x76},
	    {0x8d,0x85},
	    {0xa6,0xf0},
	    {0xae,0x9f},
	    {0xa2,0x90},
	    {0xa5,0x40},
	    {0xa7,0x30},
	    {0xb0,0x88},
	    {0x38,0x0b},
	    {0x39,0x30},
	    {0xfe,0x00},
	    {0x87,0xb0},
	 */

	///////
	{0xfe , 0x00},
	{0x90 , 0x01}, //0x//crop enable
	{0x95 , 0x04},  //0x//800x600
	{0x96 , 0xb0},
	{0x97 , 0x06},
	{0x98 , 0x40},


	{0xfe , 0x03},
	{0x42 , 0x40},
	{0x43 , 0x06}, //output buf width
	{0x41 , 0x02}, // Pclk_polarity
	{0x40 , 0x40},  //00
	{0x17 , 0x00}, //widv
	{0xfe , 0x00},
	////output DVP/////

	{0xfe , 0x00},
	{0x82 , 0xfe},  // fe
	{0xf2 , 0x70},
	{0xf3 , 0xff},
	{0xf4 , 0x00},
	{0xf5 , 0x30},

	{0xff , 0xff},
};

SENSOR_REG_T GC2035_YUV_800x600[]=
{
	/*{0xfe , 0x00},
	  {0xfa , 0x00},
	//	{0xfa , 0x22},
	{0x09 , 0x01},
	{0x0a , 0x34}, //row start
	{0x0b , 0x01},
	{0x0c , 0x9c}, //col start
	{0x0d , 0x02},
	{0x0e , 0x58},
	{0x0f , 0x03}, //Window setting
	{0x10 , 0x20},



	{0x05 , 0x02},//hb
	{0x06 , 0xa1},
	{0x07 , 0x02},//vb
	{0x08 , 0x08},

	{0xfe , 0x01},
	{0x27 , 0x00},//step
	{0x28 , 0xa0},
	{0x29 , 0x04},//level1 25 FPS
	{0x2a , 0x60},
	{0x2b , 0x06},//level2
	{0x2c , 0x40},
	{0x2d , 0x07},//level3
	{0x2e , 0x80},
	{0x2f , 0x0c},//level4
	{0x30 , 0x80},*/


	/*
	{0xc8 , 0x00},//close scaler
	{0x99 , 0x11},// 1/2 subsample
	{0x9a , 0x06},
	{0x9b , 0x00},
	{0x9c , 0x00},
	{0x9d , 0x00},
	{0x9e , 0x00},
	{0x9f , 0x00},
	{0xa0 , 0x00},
	{0xa1 , 0x00},
	{0xa2  ,0x00},

	{0x90 , 0x01},  //crop enable
	{0x95 , 0x02},
	{0x96 , 0x58},
	{0x97 , 0x03},
	{0x98 , 0x20},
	{0xb6 , 0x03},
	 */
	{0xfe , 0x00},
	{0xb6 , 0x03},
	{0xfa , 0x00},
	{0xf7 , 0x15}, //row start
	{0xf8 , 0x88}, //col start
	{0xc8 , 0x00},//close scaler

	{0x0a , 0x00}, //row start
	{0x0c , 0x00}, //col start
	{0x0d , 0x04},
	{0x0e , 0xc0},
	{0x0f , 0x06}, //Window setting
	{0x10 , 0x58},


	{0x99 , 0x22},// 1/2 subsample
	{0x9a , 0x07},
	{0x9b , 0x00},
	{0x9c , 0x00},
	{0x9d , 0x00},
	{0x9e , 0x00},
	{0x9f , 0x00},
	{0xa0 , 0x00},
	{0xa1 , 0x00},
	{0xa2  ,0x00},
	{0x90 , 0x01},  //crop enable
	{0x95 , 0x02},
	{0x96 , 0x58},
	{0x97 , 0x03},
	{0x98 , 0x20},

	{0x05 , 0x01},//hb
	{0x06 , 0x11},
	{0x07 , 0x00},//vb
	{0x08 , 0xf0},

	{0xfe , 0x01},
	{0x27 , 0x00},//step
	{0x28 , 0xf0},
	{0x29 , 0x05},//level1 25 FPS
	{0x2a , 0xa0},
	{0x2b , 0x05},//level2
	{0x2c , 0xa0},
	{0x2d , 0x05},//level3
	{0x2e , 0xa0},
	{0x2f , 0x05},//level4
	{0x30 , 0xa0},

	{0xfe , 0x00},

	{0xff , 0xff},

};

SENSOR_REG_T GC2035_YUV_1280x960[]=
{
	{0xfe , 0x00},
	{0xc8 , 0x00}, //Scaler_disable
	{0xfa , 0x00},
	//	{0xfa , 0x22},
	{0xf7 , 0x15}, //row start
	{0xf8 , 0x85},


	{0x0a , 0x00}, //row start
	{0x0c , 0x00}, //col start
	{0x0d , 0x04},
	{0x0e , 0xc0},
	{0x0f , 0x06}, //Window setting
	{0x10 , 0x58},


	{0x05 , 0x01},//hb
	{0x06 , 0x11},
	{0x07 , 0x00},//vb
	{0x08 , 0x50},
	{0xfe , 0x01},
	{0x27 , 0x00},//step
	{0x28 , 0xa0},
	{0x29 , 0x05},//level1 12.2 FPS
	{0x2a , 0x00},
	{0x2b , 0x05},//level2
	{0x2c , 0x00},
	{0x2d , 0x05},//level3
	{0x2e , 0x00},
	{0x2f , 0x0c},//level4
	{0x30 , 0x80},

	{0xfe , 0x00},
	{0x99 , 0x55},  // 4/5
	{0x9a , 0x06},
	{0x9b , 0x00},
	{0x9c , 0x00},
	{0x9d , 0x01},
	{0x9e , 0x23},
	{0x9f , 0x00},
	{0xa0 , 0x00},
	{0xa1 , 0x01},
	{0xa2  ,0x23},

	{0x90 , 0x01},  //crop enable
	{0x95 , 0x03},
	{0x96 , 0xc0},
	{0x97 , 0x05},
	{0x98 , 0x00},
	{0xff , 0xff},

};

SENSOR_REG_T GC2035_YUV_1600x1200[]=
{
	{0xfe , 0x00},
	{0xc8 , 0x00},
	{0xfa , 0x00},
	{0xf7 , 0x15}, //row start
	{0xf8 , 0x85},
	//	{0xfa , 0x22},

	{0x0a , 0x00}, //row start
	{0x0c , 0x00}, //col start
	{0x0d , 0x04},
	{0x0e , 0xc0},
	{0x0f , 0x06}, //Window setting
	{0x10 , 0x58},

	{0x05 , 0x01},//hb
	{0x06 , 0x11},
	{0x07 , 0x00},//vb
	{0x08 , 0x50},
	{0xfe , 0x01},
	{0x27 , 0x00},//step
	{0x28 , 0xa0},
	{0x29 , 0x05},//level1 12.2 FPS
	{0x2a , 0x00},
	{0x2b , 0x05},//level2
	{0x2c , 0x00},
	{0x2d , 0x05},//level3
	{0x2e , 0x00},
	{0x2f , 0x0c},//level4
	{0x30 , 0x80},


	{0xfe , 0x00},


	{0x99 , 0x11}, // disable sambsample
	{0x9a , 0x06},
	{0x9b , 0x00},
	{0x9c , 0x00},
	{0x9d , 0x00},
	{0x9e , 0x00},
	{0x9f , 0x00},
	{0xa0 , 0x00},
	{0xa1 , 0x00},
	{0xa2  ,0x00},

	{0x90 , 0x01},
	{0x95 , 0x04},
	{0x96 , 0xb0},
	{0x97 , 0x06},
	{0x98 , 0x40},
	{0xff , 0xff},
};

SENSOR_REG_T gc2035_effect_tbl[] = {
	{0x83 , 0xe0},  //Normal
	{0xff , 0xff},
};

SENSOR_REG_T gc2035_awb_tbl[] = {
	{0xfe , 0x00},	//auto
	{0xb3 , 0x60},
	{0xb4 , 0x40},
	{0xb5 , 0x60},
	{0x82 , 0xfe},
	{0xff , 0xff},
};

SENSOR_REG_T gc2035_ae_tbl[] = {
	{0xfe,0x00},  //auto
	{0xb6,0x03},
	{0xff , 0xff},
};

SENSOR_REG_T gc2035_bright_tbl[] = {
	{0xfe , 0x02},
	{0xd5 , 0x00},
	{0xfe , 0x00},
	{0xff , 0xff},
};

SENSOR_REG_T gc2035_capture_tbl[] = {
#if 1
	{0xfe , 0x00},

	{0xfa , 0x00},
	{0xc8 , 0x00},
	{0x99 , 0x22},// 1/2 subsample
	{0x9a , 0x07},
	{0x9b , 0x00},
	{0x9c , 0x00},
	{0x9d , 0x00},
	{0x9e , 0x00},
	{0x9f , 0x00},
	{0xa0 , 0x00},
	{0xa1 , 0x00},
	{0xa2  ,0x00},
	{0x90 , 0x01},	//crop enable
	{0x95 , 0x02},
	{0x96 , 0x58},
	{0x97 , 0x03},
	{0x98 , 0x20},

#else
	{0xfe , 0x00},
	{0xc8 , 0x00},
	{0xfa , 0x00},
	{0x99 , 0x11}, // disable sambsample
	{0x9a , 0x06},
	{0x9b , 0x00},
	{0x9c , 0x00},
	{0x9d , 0x00},
	{0x9e , 0x00},
	{0x9f , 0x00},
	{0xa0 , 0x00},
	{0xa1 , 0x00},
	{0xa2  ,0x00},

	{0x90 , 0x01},
	{0x95 , 0x04},
	{0x96 , 0xb0},
	{0x97 , 0x06},
	{0x98 , 0x40},


#endif
	{0xff, 0xff},
};

static void gc2035_write_reg(struct i2c_client *client, SENSOR_REG_T *pTbl)
{

	int i=0;
	dprintk("%s %s()\n", __FILE__, __func__);
	while(pTbl[i].reg != 0xff){
		sensor_write_reg(client, pTbl[i].reg, pTbl[i].val);
		i++;
	}
}

static void gc2035_write_shutter(struct i2c_client *client)
{
	sensor_write_reg(client, 0x03, (preshutter >> 8)&0xff);
	sensor_write_reg(client, 0x04, preshutter & 0xff);
}

static unsigned int gc2035_read_shutter(struct i2c_client *client)
{
	return (sensor_read_reg(client, 0x03) << 8 ) | (sensor_read_reg(client, 0x04));
}

static void gc2035_set_effect(struct i2c_client *client)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_write_reg(client, gc2035_effect_tbl);
}

static void gc2035_set_ae(struct i2c_client *client)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_write_reg(client, gc2035_ae_tbl);
}

static void gc2035_set_awb(struct i2c_client *client)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_write_reg(client, gc2035_awb_tbl);
}

static void gc2035_set_bright(struct i2c_client *client)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_write_reg(client, gc2035_bright_tbl);
}

static int gc2035_set_focus(struct jz_sensor_desc *desc)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	//gc2035 don't support auto_focus!!
	//gc2035_write_reg(client, gc2035_focus_tbl);

	return 0;
}

static void init_set(struct i2c_client *client)
{
	/*** VGA preview (640X480) 30fps 24MCLK input ***********/
	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_write_reg(client, sensor_init_data);
}

static void preview_set(struct i2c_client *client)
{
	int preview_mode = 0;

	//gc2035_set_ae(client);
	//gc2035_set_bright(client);
	//sensor_write_reg(client, 0xfa, 0x00);
	switch (preview_mode)
	{
		case 0:
			{
				//YCP_saturation
				sensor_write_reg(client,0xfe , 0x02);
				sensor_write_reg(client,0xd1 , 0x38);
				sensor_write_reg(client,0xd2 , 0x38);

				sensor_write_reg(client,0xfe , 0x01);
				sensor_write_reg(client,0x3e , 0x40);
				sensor_write_reg(client,0xfe , 0x00);
				dprintk("set_preview_mode: DCAMERA_ENVIRONMENT_NORMAL\n");
				break;
			}
		case 1://DCAMERA_ENVIRONMENT_NIGHT://1
			{
				//YCP_saturation
				sensor_write_reg(client,0xfe , 0x02);
				sensor_write_reg(client,0xd1 , 0x38);
				sensor_write_reg(client,0xd2 , 0x38);

				sensor_write_reg(client,0xfe , 0x01);
				sensor_write_reg(client,0x3e , 0x60);
				sensor_write_reg(client,0xfe , 0x00);
				dprintk("set_preview_mode: DCAMERA_ENVIRONMENT_NIGHT\n");
				break;
			}
		case 3://SENSOR_ENVIROMENT_PORTRAIT://3
			{
				//YCP_saturation
				sensor_write_reg(client,0xfe , 0x02);
				sensor_write_reg(client,0xd1 , 0x34);
				sensor_write_reg(client,0xd2 , 0x34);

				sensor_write_reg(client,0xfe , 0x01);
				sensor_write_reg(client,0x3e , 0x40);
				sensor_write_reg(client,0xfe , 0x00);
				dprintk("set_preview_mode: SENSOR_ENVIROMENT_PORTRAIT\n");
				break;
			}
		case 4://SENSOR_ENVIROMENT_LANDSCAPE://4
			{
				//nightmode disable
				sensor_write_reg(client,0xfe , 0x02);
				sensor_write_reg(client,0xd1 , 0x4c);
				sensor_write_reg(client,0xd2 , 0x4c);

				sensor_write_reg(client,0xfe , 0x01);
				sensor_write_reg(client,0x3e , 0x40);
				sensor_write_reg(client,0xfe , 0x00);
				dprintk("set_preview_mode: SENSOR_ENVIROMENT_LANDSCAPE\n");
				break;
			}
		case 2://SENSOR_ENVIROMENT_SPORTS://2
			{
				//nightmode disable
				//YCP_saturation
				sensor_write_reg(client,0xfe , 0x02);
				sensor_write_reg(client,0xd1 , 0x40);
				sensor_write_reg(client,0xd2 , 0x40);

				sensor_write_reg(client,0xfe , 0x01);
				sensor_write_reg(client,0x3e , 0x40);
				sensor_write_reg(client,0xfe , 0x00);
				dprintk("set_preview_mode: SENSOR_ENVIROMENT_SPORTS\n");
				break;
			}
		default:
			{
				break;
			}

	}
}

static void capture_set(struct i2c_client *client)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_write_reg(client, gc2035_capture_tbl);
}

static void size_switch(struct i2c_client *client, int width, int height)
{

	dprintk("%s %s()\n", __FILE__, __func__);
	if ((width == 800) && (height == 600)) {
		gc2035_write_reg(client, GC2035_YUV_800x600);
	} else if ((width == 1280) && (height == 960)) {
		gc2035_write_reg(client, GC2035_YUV_1280x960);
	} else if ((width == 1600) && (height == 1200)) {
		gc2035_write_reg(client, GC2035_YUV_1600x1200);
	} else {
		dprintk("not support\n");
	}
}

static void gc2035_power_down(int pd_pin)
{
	dprintk("%s %s() %d\n", __FILE__, __func__, pd_pin);
	/* Power Down: active high */
#if defined(CONFIG_JZ4760_LEPUS) || defined(CONFIG_JZ4760B_LEPUS)
	__gpio_as_output(pd_pin);
	__gpio_set_pin(pd_pin);
#elif defined(CONFIG_JZ4770_PISCES)|| defined(CONFIG_JZ4775_MENSA)
	__gpio_as_output1(pd_pin);
#elif defined(CONFIG_JZ4750D_CETUS)
	__gpio_as_output(pd_pin);
	__gpio_set_pin(pd_pin);
#endif
	mdelay(5);
}

static void gc2035_power_up(int pd_pin)
{
	dprintk("%s %s()\n", __FILE__, __func__);
#if defined(CONFIG_JZ4760_LEPUS) || defined(CONFIG_JZ4760B_LEPUS)
	__gpio_as_output(pd_pin);
	__gpio_clear_pin(pd_pin);
#elif defined(CONFIG_JZ4770_PISCES)|| defined(CONFIG_JZ4775_MENSA)
	__gpio_as_output0(pd_pin);
#elif defined(CONFIG_JZ4750D_CETUS)
	__gpio_as_output(pd_pin);
	__gpio_clear_pin(pd_pin);
#endif
	mdelay(5);
}

static int gc2035_set_mclk(unsigned int mclk)
{
	/*
	 * It has a 24MHz oscillator to supply Mclk on RD47xx_Camera_Board.
	 */

	dprintk("%s %s()\n", __FILE__, __func__);
	// __cim_set_master_clk(__cpm_get_hclk(), c->mclk);
	return 0;
}

static void gc2035_reset(int rst_pin)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	/* Reset: active-low */
#if defined(CONFIG_JZ4770_F4770) || defined(CONFIG_JZ4770_PISCES) || defined(CONFIG_JZ4775_F4775) || defined(CONFIG_JZ4780_F4780) || defined(CONFIG_JZ4775_MENSA)
	__gpio_as_output0(rst_pin);
	mdelay(50);
	__gpio_as_output1(rst_pin);
	mdelay(50);
#else
	__gpio_clear_pin(rst_pin);
	mdelay(50);
	__gpio_set_pin(rst_pin);
	mdelay(50);
#endif
}

static int gc2035_set_power(struct jz_sensor_desc *desc, int state)
{

	dprintk("%s %s()\n", __FILE__, __func__);
	switch (state)
	{
		case 0:
			gc2035_power_up(desc->pd_pin);
			break;
		case 1:
			gc2035_power_down(desc->pd_pin);
			break;
		case 2:
			break;
		default:
			dprintk("%s : invalid state %d! \n", __func__, state);
			return -EINVAL;
	}
	return 0;
}

static int gc2035_sensor_init(struct jz_sensor_desc *desc)
{

	dprintk("%s %s()\n", __FILE__, __func__);
	gc2035_set_mclk(desc->mclk);
	gc2035_reset(desc->rst_pin);
	init_set(desc->client);
	gc2035_set_awb(desc->client);
	gc2035_set_effect(desc->client);
	//gc2035_set_focus(desc->client);

	return 0;
}


static int gc2035_sensor_probe(struct jz_sensor_desc *desc)
{
	u8 chipid_high = 0;
	u8 chipid_low = 0;
	u8 revision = 0;
	dprintk("\n\n====gc2035_sensor_probe====\n\n");

	gc2035_power_up(desc->pd_pin);
	gc2035_reset(desc->rst_pin);
	mdelay(10);
	chipid_high = sensor_read_reg(desc->client, 0xf0);	//read product id MSBs
	chipid_low = sensor_read_reg(desc->client, 0xf1);	//read product id MSBs
	gc2035_power_down(desc->pd_pin);

	dprintk("%s L%d: chipid_high = 0x%02x,chipid_low = 0x%02x,revision = 0x%02x\n", __func__, __LINE__, chipid_high,chipid_low,revision);

	if((chipid_high != 0x20)||(chipid_low != 0x35)) {
		dprintk("==>%s: error! chipid is 0x%02x%02x, should be 0xgc2035!\n", __func__, chipid_high,chipid_low);
		return -1;
	}

	return 0;
}

static int gc2035_set_resolution(struct jz_sensor_desc *desc, struct resolution_info *res)
{
	dprintk("%s %s()\n", __FILE__, __func__);
#if 1
	size_switch(desc->client, res->width, res->height);
#endif
	return 0;
}

static int gc2035_set_function(struct jz_sensor_desc *desc, enum sensor_mode_t mode)
{
	dprintk("%s %s()\n", __FILE__, __func__);
	switch (mode)
	{
		case SENSOR_MODE_PREVIEW:
			preview_set(desc->client);
			break;
		case SENSOR_MODE_CAPTURE:
			capture_set(desc->client);
			break;
		default:
			dprintk("%s: invalid function!\n", __func__);
			break;
	}

	return 0;
}

static struct jz_sensor_ops gc2035_sensor_ops = {
	.sensor_init		= gc2035_sensor_init,
	.sensor_probe		= gc2035_sensor_probe,
	.sensor_set_resolution	= gc2035_set_resolution,
	.sensor_set_power	= gc2035_set_power,
	.sensor_set_function	= gc2035_set_function,
	.sensor_set_foucs       = gc2035_set_focus,
};

static int gc2035_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	struct jz_sensor_desc *desc = NULL;
	struct jz_sensor_platform_data *priv = client->dev.platform_data;

	dprintk("\n\n=====gc2035_probe== i ===\n\n");
	if (!id)
		return -EINVAL;

	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
	if (!desc) {
		dprintk(KERN_ERR "%s: kzalloc failed!\n", __func__);
		return -ENOMEM;
	}
	desc->client = client;
	strcpy(desc->name, id->name);

	//	desc->cim_id = priv->cim_id;	/* attached to cim 0/1 */
	desc->rst_pin = priv->rst_pin;
	desc->pd_pin = priv->pd_pin;

	desc->mclk = 24000000;
	desc->i2c_clk = 400000;		/* set i2c speed: 400KHZ */
	desc->bus_width = 8;
	desc->wait_frames = 2;
#ifdef CONFIG_VIDEO_CIM_IN_FMT_YUV444
	desc->fourcc = V4L2_PIX_FMT_YUV444;
#else
	desc->fourcc = V4L2_PIX_FMT_YUYV;
#endif
	desc->ops = &gc2035_sensor_ops;
	/* max capture resolution: 2048 x 1536 x 16 bits */
	memcpy(&desc->cap_res, &gc2035_resolution_table[0], sizeof(struct resolution_info));
	/* max preview resolution: 1024 x 768 x 16 bits */
	memcpy(&desc->pre_res, &gc2035_resolution_table[1], sizeof(struct resolution_info));
	desc->resolution_table	= gc2035_resolution_table;
	desc->table_nr = ARRAY_SIZE(gc2035_resolution_table);

	sensor_set_i2c_speed(client, desc->i2c_clk);

	/* attaching sensor to CIM host controller */
	jz_sensor_register(desc);

	i2c_set_clientdata(client, desc);

	dprintk("%s: %s probed\n", __func__, desc->name);

	return 0;
}

static int gc2035_remove(struct i2c_client *client)
{
	//	struct jz_sensor_desc *desc = container_of(client, struct jz_sensor_desc, client);
	struct jz_sensor_desc *desc = i2c_get_clientdata(client);

	dprintk("%s: %s probed\n", __func__, desc->name);

	i2c_set_clientdata(client, NULL);
	kfree(desc);

	return 0;
}

/*
 * i2c_device_id.name must be same with i2c_board_info.type !
 */
static const struct i2c_device_id gc2035_id[] = {
	{ CIM_SENSOR_NAME, 0 },
	{ }	/* Terminating entry */
};
ODULE_DEVICE_TABLE(i2c, gc2035_id);

static struct i2c_driver gc2035_driver = {
	.probe		= gc2035_probe,
	.remove		= gc2035_remove,
	.id_table	= gc2035_id,
	.driver	= {
		.name = "gc2035",
	},
};

static int __init gc2035_init(void)
{
	return i2c_add_driver(&gc2035_driver);
}

static void __exit gc2035_exit(void)
{
	i2c_del_driver(&gc2035_driver);
}

module_init(gc2035_init);
module_exit(gc2035_exit);
